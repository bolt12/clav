% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[tikz,runningheads,a4paper]{llncs}
%
\usepackage[portuges]{babel}
\usepackage[utf8x]{inputenc}

\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

%% Useful packages
\usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures

\graphicspath{ {./Images/} }
\usepackage[colorlinks=False]{hyperref} % add links inside PDF files
\usepackage{amsmath}  % Math fonts
\usepackage{amsfonts} %
\usepackage{amssymb}  %
\usepackage{multirow}
\usepackage{float}
\usepackage{cite}
\usepackage{tikz-cd}
\usepackage{listings}
\usepackage{alloy-style}
\usepackage[title]{appendix}

\begin{document}
%
\title{CLAV - ESPECIFICAÇÃO E VERIFICAÇÃO DO MODELO FORMAL}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Armando Santos \and
Gonçalo Duarte}

%
\authorrunning{Armando and Gonçalo}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Minho, Braga, Portugal}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

CLAV é uma plataforma que está a ser desenvolvida pela Direção Geral do Livro, Arquivos e Bibliotecas (DGLAB) em parceria técnica com o Departamento de Informática da Universidade do Minho, e tem como objetivo a classificação e avaliação de todos os documentos que circulam pelas instituições públicas portuguesas. Neste momento existe um modelo do problema especificado em OWL (\textit{Ontology Web Language}), mas tem sofrido várias alterações no decorrer do último ano e não existiu tempo para estudar o impacto dessas mesmas alterações nas pré-condições e invariantes do modelo. Neste projeto, inserido na Unidade Curricular de Laboratórios em Engenharia Informática (LEI) do MIEI/UM, pretende-se formalizar o modelo de raíz assim como os seus invariantes e garantir a consistência dos mesmos, sendo capaz de detetar erros que, até agora, não tenham sido identificados.

\keywords{Administração Pública \and Métodos Formais \and Engenharia Informática \and Alloy Analyzer \and OWL.}
\end{abstract}
%
%
%
\section{Introdução}

Até agora, em Portugal, não existia nenhum sistema de informação que gerisse a classificação e a avaliação dos documentos gerados no âmbito dos processos que circulam dentro das instituições públicas portuguesas. O CLAV veio mudar isso com a elaboração de um catálogo, que se pretende que venha a ser a referência nacional de todos processos da Administração Pública (AP), tendo sido modelado numa ontologia. Esta ontologia está especificada num modelo formal que representa o conjunto de conceitos referentes aos processos de negócio e aos relacionamentos entre eles. Infelizmente, todos os dados e documentação de apoio estão espalhados, desorganizados e em diferentes formatos, o que os torna extremamente difíceis de manter num domínio tão complexo como o da AP. No entanto, embora já tenham sido feitos esforços para criar um formato neutro, como a Macro-estrutura Funcional (MEF), e vários sistemas de exploração e exportação, devido aos problemas associados com a inserção manual dos dados oriundos das diversas instituições e à complexidade e instabilidade dos invariantes e restrições associadas ao modelo não é possível garantir a coerência das relações entre os processos de negócio. Esta incoerência é extremamente crítica uma vez que a classificação e avaliação dos processos possuí legislações associadas e lida com a remoção ou conservação (digital e física) de documentos governamentais\cite{clav-new}.

Deste modo, no contexto da unidade curricular de Laboratórios em Engenharia Informática do Mestrado Integrado em Engenharia Informática da Universidade do Minho e associado ao perfil de Métodos Formais em Engenharia Informática, apresentamos, neste artigo, a especificação e verificação, de raíz, da ontologia e o estudo da coerência dos invariantes e pré-condições que fazem parte dela. Devido à natureza puramente relacional inerente no domínio do problema em questão, iremos tirar partido de métodos algébricos e relacionais para nos ajudar a raciocinar sobre o problema em mãos e utilizar o Alloy \textit{model checker} para nos auxiliar a encontrar falhas no desenho do modelo.

\section{O Problema}

\begin{figure}[H]
\centering
\includegraphics[width=0.6\linewidth]{metamodel2.pdf}
\caption{Meta-modelo simplificado}
\label{metamodel}
\end{figure}

Cada instituição pública portuguesa desempenha uma função específica dentro da AP (p. ex. a prestação de cuidados de saúde), associado a cada função existe um conjunto de várias sub-funções (p. ex. a gestão de utentes e serviços clínicos) e cada sub-função possui uma lista de processos de negócio que, concretamente, se materializam em documentos (p. ex. um processo de negócio pertencente à sub-função de gestão de utentes seria o registo clínico de utentes). A Lista Consolidada (LC) possui esta estrutura hierárquica de 4 níveis\cite{clav-mod} onde os processos de negócio são passíveis de ser desdobrados para efeitos de avaliação. Cada classe da LC possui um conjunto de atributos que a descreve e a partir do 3º nível (PNs) começam a surgir relações mais complicadas entre processos no campo chamado contexto de avaliação. Este contexto de avaliação, como também iremos ver mais à frente, tem associado um conjunto de invariantes que influenciarão o campo das decisões de avaliação. Este último campo é responsável por conter a informação sobre o Prazo de Conservação Administrativa (PCA) e Destino Final (DF) de um processo que correspondem, respetivamente, ao prazo que o documento deve ser guardado e qual o seu destino uma vez que este prazo expire.

Embora as entidades principais no domínio do problema sejam as classes da LC, existem várias outras que se relacionam direta ou indiretamente com cada uma das classes e que fornecem uma maior profundidade e complexidade ao modelo como podemos observar na figura \ref{metamodel}.

Observando o meta-modelo simplificado, onde a azul se encontram os 4 nivéis de classe, verificamos que este possui uma complexidade natural mesmo sem lhe impor alguma restrição. Sendo assim, e dado o contexto sério em que o problema está inserido, torna-se claro que deve ser feita alguma coisa no que diz respeito a dar algumas garantias acerca da coerência e consistência da LC.

\subsection{Primeiro \textit{Checkpoint}}

Sendo o CLAV um projeto que já existe há 1 ano e já se encontra com alguns componentes operacionais, decidiu-se pegar em toda a documentação existente sobre o modelo e os seus requisitos e, com a ajuda do Professor José Carlos Ramalho, fazer um apanhado de todas as entidades e relações existentes. Durante esta primeira fase, bastantes das reuniões semanais serviram para apurar pequenos detalhes e dúvidas que iam surgindo.

Uma das razões que motivaram este investimento inicial, apesar de já existir uma ontologia definida pela qual nos podíamos guiar, foi a de existir muita documentação\cite{clav-new}\cite{clav-mod}\cite{clav-req} solta e incompleta que nem sempre estava de acordo com a versão mais recente da ontologia. Foi então, elaborado um documento, atualizado, que documenta os mais recentes requisitos e invariantes e que já se tornou bastante útil no refinamento da ontologia original, nomeadamente na eliminação de entidades e relações obsoletas e no apuramento do domínio e contradomínio de várias relações.

Na Secção \ref{SecModel} iremos falar mais detalhadamente sobre cada entidade e relação do modelo e na secção \ref{SecAlloy} será abordada a respetiva implementação em Alloy.

\subsection{Segundo \textit{Checkpoint}} \label{Sec2CheckP}

Uma das principais motivações deste projeto é estudar a forma como os mais variados invariantes interagem entre si e se, de alguma forma, se contradizem. É neste sentido que o Alloy, sendo uma linguagem de modelação de software leve que nos permite especificar tanto o modelo como as restrições a ele associadas, ajuda a detetar erros ingénuos e subtis.

Após o investimento inicial em colecionar todo o material relevante e necessário sobre o problema, deu-se início ao ciclo de vida de verificação do problema \cite{jno}. Apesar dos invariantes serem abordados com mais detalhes na secção \ref{SubSecInv}, é possível adiantar já que foram identificadas 38 restrições no total, sendo que 23 dessas foram acrescentadas no tal processo de verificação.

Podemos então concluir, que o Alloy teve um impacto positivo na análise das restrições do modelo e na especificação do modelo formal. É importante realçar que a utilização de um \textit{model checker} não descarta a necessidade de prova mas é muito útil para encontrar falhas de \textit{design} como pudemos constatar. A ausência de contra-exemplos dá uma grande confiança de que uma prova de correção está ao alcance.

\subsection{Avaliação Final}

Depois de validado o modelo e os seus invariantes de forma estática, isto é,
apenas verificar que as restrições impostas são coerentes e que existem
instâncias capazes de habitar o modelo, o percurso natural no ciclo de vida de
verificação seria o de modelar a passagem do tempo e as suas ações possíveis
(p. ex. a inserção de novas classes). No entanto, devido a restrições de tempo,
seria mais produtivo ser capaz de observar que instâncias, presentes na base de
dados, é que não iam de encontro às várias restrições. Nesse sentido, em relação
à última fase do projeto foram traduzidos os invariantes em Alloy para
\textit{queries} SPARQL, motor de base de dados escolhido para armazenar toda a
informação.

Devido à dimensão do modelo e quantidade de invariantes, foi colocada a hipótese
de traduzir, automaticamente, as \textit{queries} dada uma especificação.

Sendo assim, a terceira e última fase do trabalho consistiu na tradução manual
dos invariantes Alloy mais específicos para \textit{queries} SPARQL e na
exploração e desenvolvimento de uma prova de conceito capaz de gerar
automaticamente estas \textit{queries}. Estes dois últimos pontos serão explicados com
maior detalhe na secção \ref{SecQueries}

\section{Modelo Formal} \label{SecModel}

Nesta secção será abordada a especificação formal do CLAV. Será introduzida alguma notação relativa ao cálculo relacional utilizado na formalização do problema e, posteriormente, tanto as classes presentes no domínio do modelo como as relações entre estas serão enunciadas. Por último, devido à grande quantidade de invariantes existentes, apenas serão apresentados 3, que melhor ilustram a dimensão e complexidade do CLAV. A formalização apresentada nesta secção, assim como a especificação dos invariantes em notação relacional teve o contributo e ajuda do professor José Nuno Oliveira.

\subsection{Calcular com relações\cite{jno}\cite{jno-5}}

Dentro do contexto do CLAV podemos encontrar frases do género \textit{"A gestão de utentes é uma subfunção da prestação de cuidados de saúde"}, \textit{"O processo de referenciação de utentes para consultas é cruzado com o processo de registo nacional de utentes"} ou \textit{"Se um processo é complementar de outro, então o seu destino final é de conservação"}. Estas expressões podem ser interpretadas como relações tipadas entre objetos.

As relações, como as frases acima, já existem na matemática há vários anos e possuem uma notação própria capaz de as exprimir. Em geral, a notação (infixa) \textit{b R a}, onde \textit{a} e \textit{b} são os objetos e \textit{R} a relação, é a que expressa mais naturalmente as relações. Esta notação aplica-se também ao uso da voz passiva, que expressa a relação inversa de \textit{R}, denotada por \textit{Rº}, onde \textit{b R a} significa o mesmo que \textit{a Rº b}. Por exemplo, \textit{é síntese deº = é sintetizado por}.\label{rel_inv}

Também é importante observar que relações do género \textit{R = é o pai de}, são relações em que quando conhecido, o pai (p. ex. de uma classe) é único. Relações com esta propriedade são referidas como \textit{simples} e satisfazem a propriedade

\begin{equation}
\label{eq-simple}
R \circ Rº \subseteq id
\end{equation}

\noindent onde ($\circ$), denota a composição de relações, \textit{id} é a relação identidade e $\subseteq$ é a inclusão de relações:

\begin{equation}
\label{eq-subseteq}
R \subseteq S \equiv \forall b; a : b R a \Rightarrow b S a.
\end{equation}

\subsubsection{Relações tipadas e diagramas:}

O uso de setas e diagramas torna possível expressar formulas relacionais mais complexas. No entanto, para ser possível representar e raciocinar sobre estes diagramas é necessário que estes estejam bem construídos.

Observando a relação \eqref{eq-subseteq} concluímos que apenas faz sentido se \textit{R} e \textit{S} forem do mesmo tipo. A notação $B \xleftarrow[]{\text{R}} A$ declara uma relação binária que relaciona \textit{B's} com \textit{A's}. Por exemplo, B = \textit{Classe nível 1} e A = \textit{Classe nível 2} para o caso em que \textit{R = é o pai de}. 

Caminhos em diagramas são construídos a partir do encadeamento de setas, o que corresponde à composição de relações:

\begin{equation}
\label{eq-composition}
\begin{tikzcd}
A \arrow[bend right, leftarrow, swap]{rr}{R\ \circ\ S} \arrow[leftarrow]{r}{R} & B \arrow[leftarrow]{r}{S} & C
\end{tikzcd}
\hskip2cm b (R \circ S) c \equiv \exists a: b R a \land a S c
\end{equation}

Os diagramas também advêm da comparação de caminhos, por exemplo,

\begin{center}
\begin{tikzcd}[row sep=tiny]
Classe\_N2 \arrow[swap]{dd}{temFilho12} &           & ListaConsolidada \arrow[swap]{ll}{pertenceLC2} \arrow{dd}{id} \\
                                      & \subseteq &                                                       \\
Classe\_N1                      &           & ListaConsolidada \arrow{ll}{pertenceLC1}  
\end{tikzcd}
\end{center}

\noindent que representa a restrição

\begin{equation}
\label{eq-inv1}
    temFilho12 \circ pertenceLC2 \subseteq id \circ pertenceLC1,
\end{equation}

\noindent onde, no domínio do CLAV, as relações \textit{pertenceLC1} e \textit{pertenceLC2} mapeiam, respetivamente, cada classe de nível 1 na sua respetiva LC e cada classe de nível 2 na sua respetiva LC, a relação simples, \textit{temFilho12}, relaciona uma classe de nível 1 com os seus filhos (classes de nível 2), a relação \textit{id} é a conhecida relação identidade que relaciona cada objeto consigo próprio.

\subsubsection{Dos diagramas à lógica\cite{jno}\cite{jno-5}:}

O que é que a expressão \eqref{eq-inv1} significa em lógica proposicional?

\begin{equation*}
    temFilho12 \circ pertenceLC2 \subseteq id \circ pertenceLC1
\end{equation*}
$\equiv$ \{ inclusão de relações \eqref{eq-subseteq}; id \}
\begin{equation*}
    \forall\ c1, lc : c1\ (temFilho12 \circ pertenceLC2)\ lc \Rightarrow c1\ pertenceLC2\ lc
\end{equation*}
$\equiv$ \{ composição (3) \}
\begin{equation*}
    \forall\ c1, lc : (\exists\ c2 : c1\ temFilho12\ c2\ \land\ c2\ pertenceLC2\ lc) \Rightarrow c1\ pertenceLC1\ lc
\end{equation*}
$\equiv$ \{ \textit{splitting; nesting} \}
\begin{equation*}
    \forall\ c1, c2, lc : c2\ pertenceLC2\ lc \land c1\ temFilho12\ c2\ \Rightarrow \ c1\ pertenceLC1\ lc
\end{equation*}

\noindent Literalmente:
\vskip0.2cm
\textit{Se uma c2 pertence à lista consolidada lc e c2 é filho da classe c1, então c1 também pertence à lista consolidada lc.}

\vskip0.2cm
\noindent Ainda em menos palavras, a restrição \eqref{eq-inv1}, sugere:
\vskip0.2cm
\textit{Filho de quem pertence, também pertence.}

\subsection{Domínio}

%Introduzir cada uma das signatures e o seu contexto no problema.
Com a especificação do domínio do modelo formal pretendemos descrever a essência do problema em questão que é o de garantir que, dadas as entidades existentes e as suas relações, o conjunto de invariantes impostos são coerentes, não se contradizem e permitem instâncias semanticamente corretas.

Sendo assim, nesta secção e na próxima, apesar do domínio especificado ser maior, apenas iremos apresentar as especificações que melhor capturam a essência do modelo, por questões de síntese. No entanto, será possível consultar o modelo Alloy, na totalidade, em anexo.

\subsubsection{Referencial Classificativo:}

O Referencial Classificativo possui a Lista Consolidada e o conjunto de Tabelas de Seleção onde se encontram todas as classes.

\begin{equation*}
    ReferencialClassificativo = ListaConsolidada + TabelaSelecao
\end{equation*}

\subsubsection{Classes:}

Como já foi referido existem 4 níveis de classes e, como veremos na secção abaixo especificamo-las da seguinte maneira.

\begin{equation*}
    Classes = Classe\_N1 + Classe\_N2 + Classe\_N3 + Classe\_N4
\end{equation*}

\subsubsection{PCA:}

O Prazo de Conservação Administrativa é o simples tipo de dados:

\begin{equation*}
    PCA
\end{equation*}

\subsubsection{Destino Final:}

O Destino Final é passível de ser avaliado em um de três valores: \textit{Não Especificado (NE)}, \textit{Eliminação} (quando a documentação associada ao processo de negócio é eliminada, uma vez terminado o PCA) e \textit{Conservação} (quando a documentação associada ao processo de negócio deve ser preservada, uma vez terminado o PCA). Apesar de apenas existirem estes 3 valores, foi necessário distingui-los em entidades individuais devido ao facto de cada instância de um DF estar relacionada com outras entidades. Sendo assim:

\begin{equation*}
    DestinoFinal = NE + Eliminacao + Conservacao
\end{equation*}

\subsection{Relações envolvidas}

Observando apenas as entidades definidas na secção anterior não é bem clara a existência de uma hierarquia nem é clara a existência das endo-relações que fazem parte do contexto de avaliação nas de nível 3. Isto deve-se ao facto de estas características apenas se evidenciarem ao analisar as relações envolvidas entre cada uma das entidades do domínio.

É de realçar que foi feito um esforço em manter as nomenclaturas da ontologia original e devido a isso, muitas das relações inversas possuem nomes diferentes. No entanto, para efeitos de simplificação e leitura utilizaremos a notação apresentada em \ref{rel_inv} e as restrições de domínio/contradomínio serão esclarecidas no nome das relações.

\subsubsection{Visão hierárquica:}

\begin{equation}
\label{vis_geral}
\begin{tikzcd}
ListaConsolidada \arrow{d}{pertenceLC1} \arrow[swap,bend right=67]{dd}{pertenceLC2} \arrow[swap,bend right=60]{ddd}{pertenceLC3} \arrow[swap,bend right=49]{dddd}{pertenceLC4} \\
Classe\_N1 \arrow{d}{temFilho12º}                                                                                                                                     \\
Classe\_N2 \arrow{d}{temFilho23º}                                                                                                                                     \\
Classe\_N3 \arrow{d}{temFilho34º}                                                                                                                                     \\
Classe\_N4                                                                                                                                                             
\end{tikzcd}
\end{equation}

Acima, nas relações da familia \textit{pertenceLC} o número associado a elas diz respeito ao nível da classe. Nas relações da família \textit{temFilho}\footnote{Na ontologia, a relação inversa é a \textit{temPai}}, o primeiro número diz respeito ao pai e o segundo ao filho. Sendo assim, com estas relações já é possível observar a cascata hierárquica das classes de processos da Administração Pública associadas a uma Lista Consolidada.

Com esta representação gráfica podemos também concluir que o sentido do invariante \ref{eq-inv1} também se aplica às relações apresentadas, dando origem a mais dois diagramas semelhantes mas para as classes filho.

\subsubsection{Processos de negócio:}

\begin{equation}
\label{vis_pn}
\begin{tikzcd}
            &  & Classe\_N3 \arrow[loop,swap]{u}{\textit{\shortstack{eAntecessorDe \\ eComplementarDe \\ eCruzadoCom \\ eSinsteseDe \\ eSucessorDe \\ eSuplementoDe}}}                       &  &                                       \\
PCA \arrow{rru}{temPCA3} \arrow[swap, bend right]{rrrr}{temPCA4} &  & DestinoFinal \arrow[swap]{u}{temDF3} \arrow{rr}{temDF4} &  & Classe\_N4 \arrow[swap]{llu}{temFilho34}
\end{tikzcd}
\end{equation}

As endo-relações que dizem respeito aos processos de negócio na figura acima são as principais relações presentes no contexto de avaliação e que irão influenciar o resultado do Destino Final. As classes de nível 4 são casos particulares em que um PN se desdobra com um certo motivo. Nesses casos as decisões de avaliação passam para os filhos. Como podemos ver, é nos processos de negócio que se encontra uma maior densidade de relações e é também nestes que se encontra a parte mais complexa e crítica do problema e, devido a isto, a maior parte dos invariantes irá focar-se neste diagrama. É de salientar que esta figura omite entidades e relações também relevantes que lidam com legislação e critérios de justificação que poderão ser encontrados no modelo final em anexo.

\subsection{Invariantes} \label{SubSecInv}

Como já foi dado a perceber, neste projeto, apenas foi focado o domínio de relações entre cada entidade pertencente à Lista Consolidada e, dentro deste domínio reduzido, apenas foi explorado com mais profundidade a parte de classificação e avaliação de processos de negócio ignorando assim, muitas das relações de atributos e invariantes associados a estas. Como foi referido em \ref{Sec2CheckP}, foram especificados, no total, 38 invariantes sendo que, 23 desses foram adicionados como resultado deste projeto.

Tentando perceber o motivo por de trás de terem sido acrescentados tantos invariantes chegamos à conclusão de que, a maior parte deles incide em invariantes que dizem respeito à taxonomia das relações, onde a injetividade é a mais comum, e os restantes provêm do trabalho realizado neste projeto onde, em conjunto com o Professor José C. Ramalho, foram discutidos e validados e dizem respeito à parte semântica/funcional do CLAV.

\subsubsection{Injetividade:}

A injetividade garante que não existem duas instâncias da mesma entidade a relacionarem-se com uma outra entidade. Este invariante está presente em quase todas as relações uma vez que cada instância, principalmente ao nível dos PNs, está relacionada com legislação e critérios de justificação específicos e não faz sentido serem partilhados.

Generalizadamente, uma relação é injetiva quando:

\begin{equation}
\label{injetivity}
    ker\ R \subseteq id
\end{equation}

Concretamente e intuitivamente, à luz de \ref{vis_geral} e \ref{vis_pn}, uma classe não pode ter 2 pais diferentes (\ref{inv-inj-filho}) nem dois PNs (incluindo classes de nível 4) podem ter a mesma instância de DF (\ref{inv-inj-df}):

\begin{equation}
    \label{inv-inj-filho}
    ker\ temFilhoº \subseteq id
\end{equation}
\begin{equation}
    \label{inv-inj-df}
    ker\ temDF \subseteq id
\end{equation}

As restrições mais complexas envolvem são as que envolvem as endo-relações dos PNs e as que envolvem desdobramento ao 4º nível. Contextualizando, apesar de não ser frequente, um processo de negócio (nível 3) é passível de ser desdobrado em dois ou mais processos filho (nível 4) sendo que, podem existir dois motivos de desdobramento: DF distinto ou PCA distinto. As classes filho resultantes de tais desdobramentos possuem critérios de avaliação e classificação específicos que devem ser respeitados. Em baixo seguem-se 3 invariantes que caracterizam algumas das restrições impostas:

\begin{enumerate}
    \item Se uma classe de nível 3 tem filhos, então não possui DF nem PCA (o oposto caso não tenha filhos):
    
    \begin{equation}
    \label{inv-3-4}
    \begin{tikzcd}
               &  &                                       & DF \arrow{d}{i_1} \arrow[swap]{ld}{temDF}   \\
Classe\_N4 &  & Classe\_N3 \arrow[swap]{ll}{temFilho34º} & DF + PCA \arrow[bend left]{lll}{R\ = \ temFilho34º \circ [temDF, temPCA]}       \\
           &  &                                       & PCA \arrow[swap]{u}{i_2} \arrow{lu}{temPCA}
    \end{tikzcd}
    \end{equation}{}
    \begin{equation*}
        R = \perp
    \end{equation*}{}
    
    \item Um PN só pode ter uma (endo) relação com outro PN:
    
    \begin{equation}
    \begin{split}{}
        eAntecessorDe \subseteq\ & \neg (eComplementarDe \cap eCruzadoCom \\
                                & \cap eSinteseDe \cap eSintetizadoPor \\
                                & \cap eSucessorDe \cap eSuplementoDe \\
                                & \cap eSuplementoPara)
    \end{split}{}
    \end{equation}{}
    
    A disjunção desta restrição com mais 7 do género (permutações entre o lado esquerdo e direito) formam a especificação da restrição completa.
    
    \item Se um PN é complementar ou sintese de outro, então o seu DF é de conservação; se é sintetizado por outro, então o seu DF é de eliminação; caso não seja nenhum dos especificados, o seu DF é NE (não especificado).
    
    Dividindo em várias cláusulas obtemos e assumindo que o PN não tem filhos:
    
    \begin{equation}
        eComplementarDe \backslash (temDF \circ \underline{Conservacao})
    \end{equation}{}
    \begin{equation}
        (\neg eComplementarDe \cap eSinteseDe) \backslash (temDF \circ \underline{Conservacao})
    \end{equation}{}
    \begin{equation}
    \begin{split}
        & (\neg eComplementarDe \cap \neg eSinteseDe \cap eSintetizadoPor) \\
        & \backslash (temDF \circ \underline{Eliminacao})
    \end{split}{}
    \end{equation}{}
    \begin{equation}
    \begin{split}
        & (\neg eComplementarDe \cap \neg eSinteseDe \cap \neg eSintetizadoPor) \\
        & \backslash (temDF \circ \underline{NE})
    \end{split}{}
    \end{equation}{}
\end{enumerate}
% Falar/Enumerar/Explicar alguns invariantes

\section{Modelação em ALLOY} \label{SecAlloy}

A partir do momento em que a formalização está completa resta-nos verificar se, dados os invariantes e a sua conjunção, existem instâncias capazes de habitarem o modelo. Uma solução seria, aleatoriamente e manualmente, popular os conjuntos de cada entidade e de forma \textit{ad hoc} e dispendiosa, verificar se aquele conjunto poderia habitar o modelo. Outra solução bastante mais eficaz será a de recorrer a um \textit{model checker} que, de forma automática, faz essa geração e verificação por nós. As ferramentas de \textit{model checking} tornam o ciclo de vida de verificação muito mais produtivo.

É aqui que o Alloy Analyzer tem impacto e ajuda a perceber que tipo de refinamento deve ser dado ao modelo formalizado e de que maneira é que os invariantes têm impacto nas instâncias possíveis. Nesta secção será abordada a maneira como foi feita a tradução do modelo formal, assim como os seus invariantes para Alloy.

\subsection{Especificação}

Começando pelo domínio do modelo, a cada entidade corresponderá uma \textit{sig} em Alloy. A noção de herança, capturada pelas Classes, Referencial Classificativo e Destino Final é traduzida pelas primitivas \textit{abstract} e \textit{extends}, inspiradas pela programação orientada a objetos. Sendo Assim:

\begin{lstlisting}[language=alloy, frame=single]
abstract sig ReferencialClassificativo {}
sig ListaConsolidada extends ReferencialClassificativo {}
sig TabelaSelecao extends ReferencialClassificativo {}

/* ---- */

abstract sig Classe {}

sig Classe_N1 extends Classe {}
sig Classe_N2 extends Classe {}
sig Classe_N3 extends Classe {}
sig Classe_N4 extends Classe {}


/* ---- */

abstract sig DestinoFinal {
    temJustificacao: one Justificacao
}
sig Eliminacao, Conservacao, NE extends DestinoFinal {}
\end{lstlisting}{}

No que diz respeito às relações envolvidas, o Alloy permite especificar as relações entre cada entidade da seguinte forma:

\begin{lstlisting}[language=alloy, frame=single]
sig Classe_N1 extends Classe {
    temFilho: set Classe_N2,
}
\end{lstlisting}{}

Como podemos ver, está definida uma relação $Classe\_N2 \xleftarrow[]{\text{temFilho}} Classe\_N1$ com uma cardinalidade \textit{set} no contradomínio, ou seja, $temFilho$ é uma relação de 0 para muitos. Mais concretamente, a relação especificada é a relação $temFilho12$ como podemos concluir olhando para o domínio e contradomínio. Uma última nota em relação à forma como foi traduzido o modelo, é a de que apesar de ser mais intuitivo na notação relacional representar uma relação como $y R x$, onde $Y \xleftarrow[]{\text{R}} X$, em Alloy é mais intuitivo modelar da forma $x R y$. Mesmo a composição relacional é feita da esquerda para a direita, ao contrário da notação relacional.

\subsection{Verificação}

O Alloy permite especificar expressões em lógica de primeira ordem. Para isso, disponibiliza as palavras reservadas \textit{all} e \textit{some} para quantificar universalmente e existencialmente, respetivamente, variáveis tipadas no universo modelado.

Uma das vantagens de utilizar a ferramenta Alloy é a de tudo poder ser visto como uma relação o que ajuda na tradução do modelo em si, como vimos na secção anterior, mas também permite fazer uma tradução praticamente direta dos invariantes em notação relacional \textit{point wise}, com o auxilio dos quantificadores, ou \textit{point free}, com o auxilio da composição de relações.

Com isto, e pela mesma ordem, segue-se a tradução dos invariantes apresentados em \ref{SubSecInv}:
\begin{enumerate}
    \item
    \label{inv-simples}
    \begin{lstlisting}[language=alloy, frame=single]
all c:Classe_N3 | 
    some c.temFilho => no c.temDF and no c.temPCA
    \end{lstlisting}{}
    
    \item
    \begin{lstlisting}[language=alloy, frame=single]
all c1,c2:Classe_N3 | 
    c1->c2 in eAntecessorDe 
        => c1->c2 not in eComplementarDe + eCruzadoCom 
                         + eSinteseDe + eSintetizadoPor 
                         + eSucessorDe + eSuplementoDe 
                         + eSuplementoPara
    \end{lstlisting}{}
    
    \item
    \begin{lstlisting}[language=alloy, frame=single]
all c:Classe_N3 | no c.temFilho => {
    some c.eComplementarDe => c.temDF in Conservacao
}
all c:Classe_N3 | no c.temFilho => {
    !(some c.eComplementarDe) and (some c.eSinteseDe) 
        => c.temDF in Conservacao
}
all c:Classe_N3 | no c.temFilho => {
    !(some c.eComplementarDe) and !(some c.eSinteseDe) 
    and (some c.eSintetizadoPor) 
        => c.temDF in Eliminacao
}
all c:Classe_N3 | no c.temFilho => {
    !(some c.eComplementarDe) and !(some c.eSinteseDe) 
    and !(some c.eSintetizadoPor) 
        => c.temDF in NE
}
    \end{lstlisting}{}
\end{enumerate}{}

\section{Tradução de \textit{queries} SPARQL}
\label{SecQueries}

Um modelo formal em Alloy permite raciocinar, utilizando cálculo relacional e
métodos matemáticos, sobre o problema e, tirando partido do \textit{model
checker}, eliminar erros de conceção ingénuos ou que possam ter passado
despercebidos. O modelo apresentado nas secções anteriores é apenas um modelo
estático sendo que sabemos apenas, com alguma certeza, de que este é passível de
ser habitado. No entanto, para que este evolua, a partir de um estado inicial,
é necessária a execução de um conjunto de operações. Entre outras, estas operações correspondem a
ações de inserção, atualização, remoção de instâncias no modelo e não devem
permitir que as restrições impostas sejam , isto é, devem preservar os invariantes.

Um próximo passo na especificação do modelo formal do CLAV seria o de
especificar tais ações, estudando assim a passagem do tempo e que tipo de
propriedades, tanto de \textit{safety} como de \textit{liveness}, seriam
verificadas. Mas, devido ao estado avançado do projeto, um passo alternativo, e mais produtivo uma vez que já se encontra em produção, é o de
a partir da especificação dos invariantes, traduzi-los em \textit{queries}
SPARQL que apanhem as instâncias da base de dados que não verificam as
restrições impostas. Desta forma, será fácil identificar as anomalias no sistema
e resolvê-las.

A tradução dos invariantes poderá ser feita de duas formas: manualmente ou
automaticamente. Nas secções abaixo será explicada de que forma é que ambas
estas formas de tradução podem ser executadas.

\subsection{Tradução manual}

Numa primeira vista, a sintaxe de uma \textit{query} SPARQL, sendo este motor
orientado a grafos, é bastante semelhante à de um motor de bases de dados
relacional como podemos ver em baixo.

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX P: <URI>

SELECT ?Property1 ?Property2

WHERE {
    ?v1 P:rel1 ?Property1 .
    ?v1 P:rel2 ?Property2 .
}
\end{lstlisting}

Resumidamente, e como podemos observar, o processador SPARQL funciona com
\textit{pattern matching} de triplos RDF. Baseado em lógica de primeira ordem e
teoria de conjuntos, suporta operadores como a união e interseção,
que permitem uma manipulação dos resultados de forma bastante simples e
intuitiva.

A partir desta informação, e sabendo que o Alloy é baseado em lógica de primeira
ordem e álgebra relacional, é possível inferir que estas duas linguagens possuem
bastantes semelhanças. A verdade é que, para os invariantes mais simples a
tradução é quase direta havendo apenas o pequeno pormenor que é o facto de ser necessário
especificar a \textit{query} na forma do invariante negado e em formato CNF
(\textit{Conjunctional Normal Form}).

Ilustrando então com um exemplo simples, a forma negada do invariante \ref{inv-simples} será:

\begin{lstlisting}[language=alloy, frame=single]
some c:Classe_N3 | 
    (some c.temFilho) and ((some c.temDF) or (some c.temPCA))
\end{lstlisting} 

A tradução manual deste invariante passa por analisar o tipo de variáveis a
identificar onde, neste caso, serão do tipo \texttt{Classe\_N3} e filtrar os
resultados pelas instâncias que verificam as condições impostas no corpo do
invariante. O processador SPARQL possui o operador FILTER que permite fazer esta
filtragem, resultando na \textit{query} seguinte:

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT * WHERE {
   ?c rdf:type :Classe_N3 .
   ?c :temFilho ?cf .

    FILTER (
        EXISTS { ?c :temDF ?df . } ||
        EXISTS { ?c :temPCA ?pca . }
    )
}
\end{lstlisting} 

\textit{Queries} mais complexas e que envolvam composição de relações, uma vez
que o SPARQL não é capaz de tal funcionalidade, a \textit{query} deve
explicitamente unificar as variáveis de forma obter o mesmo comportamento.
Veja-se o exemplo:

\begin{lstlisting}[language=alloy, frame=single]
some c:Classe_N3,t:c.temTI | 
    (some c.temFilho) and (t not in c.temFilho.temTI)
\end{lstlisting} 

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT * WHERE { 
    ?c rdf:type :Classe_N3 .
    ?c :temFilho ?cf .
    ?c :temTI ?ti .
   	
    FILTER (
        NOT EXISTS { ?cf :temTI ?ti . }
	)
}
\end{lstlisting} 

Esta sistematização dá uma boa confiança de que a automação deste processo está
ao alcance e, demonstra a importância e utilidade do ciclo de vida de verificação na produtividade e qualidade do trabalho produzido onde,
a formalização dos invariantes em Alloy permite perceber o impacto destes no modelo e extrair de forma correta \textit{queries} SPARQL que 
identificam instâncias incorretas na aplicação em produção.

\subsection{Geração automática}

Como vimos anteriormente, o processo de tradução da especificação de um
invariante em Alloy para uma \textit{query} SPARQL passa por várias fases. A
primeira fase é a da negação do invariante em si, utilizando regras de lógica de
primeira ordem conhecidas. A segunda fase, passa por identificar as variáveis
quantificadas e o seu tipo sendo que, estas serão traduzidas em unificações do
tipo: \texttt{?var rdf:type :<Tipo>}. A terceira fase passa por identificar, no
corpo do invariante quais as condições que as variáveis unificadas devem
respeitar de forma a encontrar as instâncias incorretas da base de dados. Esta
última fase, tira partido do operador FILTER como mencionado na secção anterior.

Para ser possível sistematizar este processo é necessário carregar o invariante
numa estrutura que permita a sua manipulação de forma prática, ou seja, é
necessário efetuar o \textit{parsing} do invariante para uma estrutura de dados.
Para este efeito, recorreu-se ao par Happy + Alex, bibliotecas em Haskell que
permitem a especificação de uma gramática e de um \textit{lexer} e respetivas
ações semânticas a partir de uma DSL (\textit{Domain Specific Language}) bastante
semelhante à das ferramentas Yacc/Flex da linguagem C, para obter a árvore sintática,
e à biblioteca \textit{recursion-schemes} para a sua manipulação. É de
salientar que o gerador desenvolvido tem como objetivo ser apenas uma prova de
conceito logo, é apenas capaz de efetuar o \textit{parsing} de um sub conjunto
bastante limitado da sintaxe Alloy e de gerar \textit{queries} a partir de
especificações bastante simples.

Tendo o \textit{parsing} feito, apenas é necessário transformar a estrutura
obtida fazendo-a passar pelas várias fases enunciadas em cima. A codificação das
várias fases em Haskell foi bastante simples devido à escolha de manter o nome
das relações usadas na ontologia base no modelo Alloy pois, não foi necessário
fazer nenhuma correspondência entre os nomes. Sendo assim, segue-se abaixo, o resultado da 
\textit{query} gerada automaticamente a partir do invariante escolhido na secção
anterior:

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#> 
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 

SELECT * WHERE {


    ?c rdf:type :Classe_N3 . 

    FILTER ( 
        EXISTS { 	
            ?c :temFilho ?blG . 
        } 

    && (
        EXISTS { 	
         ?c :temDF ?76V . 
        } 

    || 
        EXISTS { 	
         ?c :temPCA ?FIn . 
        } 
    ))

}
\end{lstlisting}

Pode-se afirmar que as \textit{queries} geradas são traduções corretas uma vez que ambas as
ferramentas (SPARQL e Alloy) são baseadas nos mesmo princípios teóricos logo,
partilham, à partida, de uma representação base.

\section{Dificuldades}

Durante o desenvolvimento do projeto foram surgindo algumas dificuldades que impactaram na produtividade e no progresso do trabalho. Apesar dos aspetos negativos associados às dificuldades encontradas, nem sempre a sua existência foi vista como algo mau.

O facto da documentação do projeto do CLAV, na fase inicial, ter estado espalhada, desorganizada e desatualizada afetou negativamente o progresso do trabalho uma vez que, foi necessário agrupar toda a informação relevante e organizá-la, de forma a facilitar as fases de desenvolvimento futuras. Alguns dos invariantes identificados eram ambíguos, característica da linguagem natural onde foram especificados, e apesar de este facto dificultar a interpretação dos mesmos, a aplicação de métodos rigorosos contribuiu para o refinamento destes.

Outra dificuldade que também contribuiu significativamente para o resultado final deste trabalho foram as restrições de tempo. Uma vez que este trabalho foi realizado em paralelo com mais quatro unidades curriculares, houve um período de estagnação (época de exames) onde os autores não tiveram tanta capacidade de trabalho.

\section{Conclusão e Trabalho Futuro} \label{SecConclusion}

Observando o trabalho no seu estado final\footnote{https://github.com/bolt12/clav}, é possível afirmar que este foi concluído com sucesso. O trabalho conseguiu alcançar todos os objetivos propostos: a formalização do modelo e a verificação deste. A utilização de métodos formais e, em particular, o \textit{model checker} Alloy, foram bastante eficazes em detetar erros que não tinham sido identificados.

Para além dos objetivos propostos, foi ainda apresentada uma prova de conceito que visa aumentar e melhorar a produtividade de trabalhos futuros de um tradutor de invariantes Alloy em \textit{queries} SPARQL. Este trabalho adicional foi inspirado no facto de o CLAV ser um projeto que já se encontra em produção e não teve a capacidade de adotar os métodos apresentados ao longo deste relatório mais cedo.

O modelo formal apresentado em anexo consiste apenas na formalização da Lista Consolidada e das relações presentes na classificação e avaliação dos processos de negócio. Na realidade, o CLAV possui outros componentes complexos que irão interagir entre si e necessitam de alguma garantia de correção. Sendo assim, um trabalho futuro poderá consistir em formalizar o resto do modelo que diz respeito ao CLAV e assistir a sua implementação de forma correta antes que seja tarde demais! 

Outro plano futuro, poderá ser o de melhorar a ferramenta de tradução automática de invariantes, de forma a suportar funcionalidades mais complexas. É de salientar que já existe algum trabalho, bastante incompleto, relacionado com a reescrita de expressões OWL/DL\cite{q-trad} em SPARQL, levando em conta a semântica OWL e SPARQL. Este trabalho relacionado, apresenta algumas regras de reescrita formalizadas que poderão dar jeito implementar na prova de conceito (com alguns ajustes) uma vez que, a lógica descritiva possui uma semântica bastante semelhante à do Alloy.

Concluindo, apesar deste trabalho ter contribuído significativamente para melhorar a correção do modelo da Lista Consolidada, eliminar bastantes falhas e adicionar invariantes que não tinham sido considerados, proporcionou um ambiente de desenvolvimento melhor ao anterior, baseado numa evolução incremental e não estudada do modelo, fornecendo a base para que o ciclo de verificação possa continuar e uma ferramenta (a de tradução) para que, num ambiente de produção, seja possível identificar de forma automática os erros de instância presentes

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\bibliographystyle{splncs04}
\bibliography{mybib}{}

\newpage

\begin{subappendices}
\renewcommand{\thesection}{\Alph{section}}%
% or try \arabic{section}

\section{Invariantes}

\hypertarget{uxedndice}{%
\subsection{Índice}\label{uxedndice}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{ux5cux25C3ux5cux25ADndice}{Índice}
\item
  \protect\hyperlink{invariantes}{Invariantes}

  \begin{itemize}
  \tightlist
  \item
    \protect\hyperlink{indice}{Indice}
  \item
    \protect\hyperlink{classes-de-1-nivel}{Classes
    de 1º Nível}
  \item
    \protect\hyperlink{classes-de-2-nivel}{Classes
    de 2º Nível}
  \item
    \protect\hyperlink{classes-de-3-nivel-com-desdobramento}{Classes
    de 3º Nível com desdobramento.}
  \item
    \protect\hyperlink{invariantes-sobre-os-pns-classe-3}{Invariantes
    sobre os PNs (Classe 3)}
  \item
    \protect\hyperlink{invariantes-sobre-a-relacaoo-suplementar-implicacoes-no-pca}{Invariantes
    sobre a relação Suplementar: implicações no PCA}
  \item
    \protect\hyperlink{invariantes-sobre-a-relacao-sintese-implicacoes-no-df}{Invariantes
    sobre a relação Síntese: implicações no DF}
  \item
    \protect\hyperlink{invariantes-sobre-a-relacao-complementar-implicacoes-no-df}{Invariantes
    sobre a relação Complementar: implicações no DF}
  \item
    \protect\hyperlink{invariantes-sobre-o-df}{Invariantes sobre o DF}
  \item
    \protect\hyperlink{invariantes-sobre-o-pca}{Invariantes sobre o PCA}
  \item
    \protect\hyperlink{invariantes-sobre-os-termos-de-indice}{Invariantes
    sobre os Termos de Índice}
  \item
    \protect\hyperlink{invariantes-das-relacoes-temrelproc}{Invariantes
    das relações \texttt{temRelProc}}
  \item
    \protect\hyperlink{invariantes-sobre-as-justificacoes}{Invariantes
    sobre as Justificações}
  \end{itemize}
\end{itemize}

\hypertarget{invariantes}{%
\subsection{Invariantes}\label{invariantes}}

A numeração dos invariantes corresponde à numeração do Alloy.

\hypertarget{indice}{%
\subsubsection{Indice}\label{indice}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{inv1}{inv1}
\item
  \protect\hyperlink{inv2}{inv2}
\item
  \protect\hyperlink{inv3}{inv3}
\item
  \protect\hyperlink{inv4}{inv4}
\item
  \protect\hyperlink{inv5}{inv5}
\item
  \protect\hyperlink{inv6}{inv6}
\item
  \protect\hyperlink{inv7}{inv7}
\item
  \protect\hyperlink{inv8}{inv8}
\item
  \protect\hyperlink{inv9}{inv9}
\item
  \protect\hyperlink{inv10}{inv10}
\item
  \protect\hyperlink{inv11}{inv11}
\item
  \protect\hyperlink{inv12}{inv12}
\item
  \protect\hyperlink{inv13}{inv13}
\item
  \protect\hyperlink{inv14}{inv14}
\item
  \protect\hyperlink{inv15}{inv15}
\item
  \protect\hyperlink{inv16}{inv16}
\item
  \protect\hyperlink{inv17}{inv17}
\item
  \protect\hyperlink{inv18}{inv18}
\item
  \protect\hyperlink{inv19}{inv19}
\item
  \protect\hyperlink{inv19}{inv20}
\item
  \protect\hyperlink{inv21}{inv21}
\item
  \protect\hyperlink{inv22}{inv22}
\item
  \protect\hyperlink{inv23}{inv23}
\item
  \protect\hyperlink{inv24}{inv24}

  \begin{itemize}
  \tightlist
  \item
    \protect\hyperlink{inv24-1}{inv24-1}
  \item
    \protect\hyperlink{inv24-2}{inv24-2}
  \item
    \protect\hyperlink{inv24-3}{inv24-3}
  \end{itemize}
\item
  \protect\hyperlink{inv25}{inv25}
\item
  \protect\hyperlink{inv26}{inv26}
\item
  \protect\hyperlink{inv27}{inv27}
\item
  \protect\hyperlink{inv28}{inv28}
\item
  \protect\hyperlink{inv29}{inv29}
\item
  \protect\hyperlink{inv30}{inv30}
\item
  \protect\hyperlink{inv31}{inv31}
\item
  \protect\hyperlink{inv32}{inv32}
\item
  \protect\hyperlink{inv33}{inv33}
\item
  \protect\hyperlink{inv34}{inv34}
\item
  \protect\hyperlink{inv35}{inv35}
\item
  \protect\hyperlink{inv36}{inv36}
\item
  \protect\hyperlink{inv37}{inv37}
\end{itemize}

\hypertarget{classes-de-1-nivel}{%
\subsubsection{Classes de 1º Nível}\label{classes-de-1uxba-nuxedvel}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv1}{\textbf{(inv1)}} Se uma Classe\_N1 pertence a uma LC/TS,
  consequentemente os seus filhos, netos, etc.. tambem têm de pertencer.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c1 rdf:type :Classe_N1 .
    ?c1 :pertenceLC ?lc1 .
    
    ?c2 rdf:type :Classe_N2 .
    ?c2 :temPai ?c1 .
    ?c2 :pertenceLC ?lc2 .
    
    ?c3 rdf:type :Classe_N3 .
    ?c3 :temPai ?c2 .
    ?c3 :pertenceLC ?lc3 .
    
    ?c4 rdf:type :Classe_N4 .
    ?c4 :temPai ?c3 .
    ?c4 :pertenceLC ?lc4 .
    
    FILTER (
        ?c1 != ?c2 
        && ?c2 != ?c3
        && ?c3 != ?c4
        && (?lc1 != ?lc2
            || ?lc2 != ?lc3
            || ?lc3 != ?lc4)
    )
    
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv2}{\textbf{(inv2)}} Se uma Classe\_N1 não pertence a uma LC/TS,
  consequentemente os seus filhos, netos, etc.. tambem não pertencem.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c1 rdf:type :Classe_N1 .
    
    minus {
        ?c1 :pertenceLC ?lc1 .
    }
    
    ?c2 rdf:type :Classe_N2 .
    ?c2 :temPai ?c1 .
    
    ?c3 rdf:type :Classe_N3 .
    ?c3 :temPai ?c2 .
    
    ?c4 rdf:type :Classe_N4 .
    ?c4 :temPai ?c3 .
    
    FILTER (
      ?c1 != ?c2 
      && ?c2 != ?c3
      && ?c3 != ?c4 &&
      (EXISTS { ?c2 :pertenceLC ?lc2 . }
      || EXISTS { ?c3 :pertenceLC ?lc3 . }
      || EXISTS { ?c4 :pertenceLC ?lc4 . })
    )
    
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv24-1}{\textbf{(inv24-1)}} 2 Classe\_N1 nao podem ter a mesma instancia
  NotaAplicacao
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c1 :temNotaAplicacao ?o.
    ?c2 :temNotaAplicacao ?o.
    FILTER (
            ?c1 != ?c2
    )
}
\end{lstlisting}

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{22}
  \tightlist
  \item
    2 Classe\_N1 nao podem ter a mesma instancia NotaExclusao
  \end{enumerate}
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
Igual a cima
\end{lstlisting}

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{22}
  \tightlist
  \item
    2 Classe\_N1 nao podem ter a mesma instancia ExemploNotaAplicacao
  \end{enumerate}
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
Igual a cima
\end{lstlisting}

\hypertarget{classes-de-2-nivel}{%
\subsubsection{Classes de 2º Nível}\label{classes-de-2uxba-nuxedvel}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv24-2}{\textbf{(inv24-2)}} 2 Classe\_N3 nao podem ter a mesma instancia
  NotaAplicacao
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
Igual a cima
\end{lstlisting}

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{23}
  \tightlist
  \item
    2 Classe\_N3 nao podem ter a mesma instancia NotaExclusao
  \end{enumerate}
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
Igual a cima
\end{lstlisting}

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{23}
  \tightlist
  \item
    Classe\_N3 nao podem ter a mesma instancia ExemploNotaAplicacao
  \end{enumerate}
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
Igual a cima
\end{lstlisting}

\hypertarget{classes-de-3-nivel-com-desdobramento}{%
\subsubsection{Classes de 3º Nível com
desdobramento.}\label{classes-de-3uxba-nuxedvel-com-desdobramento.}}

\begin{itemize}
\tightlist
\item
  Classes\_N3 com desdobramento:

  \begin{itemize}
  \tightlist
  \item
    \hypertarget{inv5}{\textbf{(inv5)}} Os 4ºs niveis herdam as legislações existentes no 3
    nivel (subconjunto), quer para o PCA quer para o DF
  \item
    \hypertarget{inv6}{\textbf{(inv6)}} Só existe desdobramento caso o PCA ou DF sejam
    distintos
  \end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :temFilho ?cf1 .
    ?c :temFilho ?cf2 .

    ?cf1 :temDF ?df1 .
    ?cf2 :temDF ?df2 .
    ?df1 :dfValor ?dfv1 .
    ?df2 :dfValor ?dfv2 .

    ?cf1 :temPCA ?pca1 .
    ?cf2 :temPCA ?pca2 .
    ?pca1 :pcaValor ?pcav1 .
    ?pca2 :pcaValor ?pcav2 .

    FILTER (
      ?cf1 != ?cf2
      && ?dfv1 = ?dfv2
      && ?pcav1 = ?pcav2
    )
}
\end{lstlisting}

  \begin{itemize}
  \tightlist
  \item
    PCA distinto

    \begin{itemize}
    \tightlist
    \item
      deve ser possível diferenciar as relações de cada uma das
      subdivisões ao 4º nível (por exemplo o critério de utilidade
      administrativa em cada um dos 4ºs níveis reflete relações
      suplementares com 3ºs níveis distintos; ou apenas uma subdivisão
      de 4º nível tem critério legal) \textbf{Vão ter um criterio de
      utilidade administrativa que referenciam classes nivel 3 distintas
      entre eles}. (\textbf{PENDENTE})
    \item
      \hypertarget{inv7}{\textbf{(inv7)}} O DF é avaliado tendo em conta o contexto de 3º
      nivel, em que:

      \begin{itemize}
      \tightlist
      \item
        Se for distinto tem que haver uma relação de sintese entre as
        classes 4 filhas.
      \item
        Se for igual não interessa
      \end{itemize}
    \end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c rdf:type :Classe_N3 .
    ?c :temFilho ?cf1 .
    ?c :temFilho ?cf2 .

    ?cf1 :temPCA ?pca1 .
    ?cf2 :temPCA ?pca2 .
    ?pca1 :pcaValor ?pcav1 .
    ?pca2 :pcaValor ?pcav2 .

    ?cf1 :temDF ?df1 .
    ?cf2 :temDF ?df2 .
    ?df1 :dfValor ?dfv1 .
    ?df2 :dfValor ?dfv2 .

    FILTER (
      ?cf1 != ?cf2
      && ?pcav1 != ?pcav2
      && ?dfv1 != ?dfv2
      && NOT EXISTS { ?cf1 :eSinteseDe ?cf2 . }
    )
}
\end{lstlisting}
  \item
    \hypertarget{inv8}{\textbf{(inv8)}} DF distinto

    \begin{itemize}
    \tightlist
    \item
      Deve haver uma relação de sintese (de ou por) entre as classes 4
      filhasa
    \item
      O PCA é igual
    \end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
?c rdf:type :Classe_N3 .
?c :temFilho ?cf1 .
?c :temFilho ?cf2 .

?cf1 :temPCA ?pca1 .
?cf2 :temPCA ?pca2 .
?pca1 :pcaValor ?pcav1 .
?pca2 :pcaValor ?pcav2 .

?cf1 :temDF ?df1 .
?cf2 :temDF ?df2 .
?df1 :dfValor ?dfv1 .
?df2 :dfValor ?dfv2 .


FILTER (
  ?cf1 != ?cf2
  && ?dfv1 != ?dfv2
  && (
  NOT EXISTS { ?cf1 :eSinteseDe ?cf2 . }
  || ?pcav1 != ?pcav2)
)
}
\end{lstlisting}
  \item
    \hypertarget{inv9}{\textbf{(inv9)}} Os termos de indice vao para os 4ºs niveis
    (repetidos)
  \end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c rdf:type :Classe_N3 .
    ?c :temFilho ?cf .
    ?c :temTI ?ti .

    FILTER (
        NOT EXISTS { ?cf :temTI ?ti . }
    )
}
\end{lstlisting}
\item
  \hypertarget{inv3}{\textbf{(inv3)}} As relações \texttt{temDF} e \texttt{temPCA}, não
  existem numa classe 3 se esta tiver filhos.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
   ?c rdf:type :Classe_N3 .
   ?c :temFilho ?cf .

    FILTER (
        EXISTS { ?c :temDF ?df . } ||
        EXISTS { ?c :temPCA ?pca . }
    )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv4}{\textbf{(inv4)}} As relações \texttt{temDF} e \texttt{temPCA}, existem
  numa classe 3 se esta \textbf{não} tiver filhos.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
   ?c rdf:type :Classe_N3 .
   
   FILTER (
      NOT EXISTS { ?c :temFilho ?cf . } &&
      (NOT EXISTS { ?c :temDF ?df . } ||
      NOT EXISTS { ?c :temPCA ?pca . })
   )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Um PN tem sempre um PCA e um DF. O valor do PCA poderá ser nulo se o
  PCA tiver uma nota associada.
\item
  \hypertarget{inv10}{\textbf{(inv10)}} Se um PN (Classe 3) for \textbf{complementar} de
  outro que se desdobra ao 4º nível, é necessário, com base no critério
  de complementaridade informacional, a relação manter-se ao 3º nível.
  Pelo menos um dos 4ºs níveis deve ser de \textbf{conservação}.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c1 rdf:type :Classe_N3 .
    ?c2 rdf:type :Classe_N3 .

    ?c1 :eComplementarDe ?c2 .
    ?c2 :temFilho ?c2f .

    ?c2f :temDF ?df .
    ?df :dfValor ?dfv .

    FILTER (
      ?c1 != ?c2
      && ?dfv != "C"
    )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv11}{\textbf{(inv11)}} Um processo só tem participantes se for
  \textbf{transversal} (Se o campo `transversal' tiver o valor sim).
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :processoTransversal "N" .
    
    FILTER (
        EXISTS { ?c :temParticipanteComunicador ?ca . }
        ||
        EXISTS { ?c :temParticipanteIniciador ?ca . }
        ||
        EXISTS { ?c :temParticipanteApreciador ?ca . }
        ||
        EXISTS { ?c :temParticipanteDecisor ?ca . }
        ||
        EXISTS { ?c :temParticipanteAssessor ?ca . }
        ||
        EXISTS { ?c :temParticipanteExecutor ?ca . }
    )
}
\end{lstlisting}

\begin{itemize}
\item
  Uma classe N3 tem de ter sempre pelo menos um dono.
\item
  \hypertarget{inv24-3}{\textbf{(inv24-3)}} 2 Classe\_N3 nao podem ter a mesma instancia
  NotaAplicacao
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{24}
  \tightlist
  \item
    2 Classe\_N3 nao podem ter a mesma instancia NotaExclusao
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumi{(\arabic{enumi})}
  \setcounter{enumi}{24}
  \tightlist
  \item
    2 Classe\_N3 nao podem ter a mesma instancia ExemploNotaAplicacao
  \end{enumerate}
\item
  \hypertarget{inv25}{\textbf{(inv25)}} 2 Classe\_N3 nao podem ter os mesmos filhos
\item
  \hypertarget{inv26}{\textbf{(inv26)}} 2 Classe\_N3 nao podem ter o mesmo TI
\end{itemize}

\hypertarget{invariantes-sobre-os-pns-classe-3}{%
\subsubsection{Invariantes sobre os PNs (Classe
3)}\label{invariantes-sobre-os-pns-classe-3}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv12}{\textbf{(inv12)}} As relações \texttt{eComplementarDe} e
  \texttt{eCruzadoCom} são simétricas.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c1 :eComplementarDe ?c2 .
    ?c3 :eCruzadoCom ?c4 .

    FILTER (
        ?c1 != ?c2 
        && ?c3 != ?c4
        && NOT EXISTS { ?c2 :eComplementarDe ?c2 . }
        && NOT EXISTS { ?c4 :eCruzadoCom ?c3 . }
    )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv14}{\textbf{(inv14)}} As relações \texttt{eSinteseDe}, \texttt{eSucessorDe}
  e \texttt{eSuplementoDe} são antisimétricas.
  (\textbf{\texttt{eSuplementoDe} ou \texttt{eSuplementoPara} ?? As
  duas})
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c1 :eSinteseDe ?c2 .
    ?c2 :eSinteseDe ?c1 .

    ?c3 :eSintetizadoPor ?c4 .
    ?c4 :eSintetizadoPor ?c3 .

    ?c5 :eSucessorDe ?c6.
    ?c6 :eSucessorDe ?c5.

    ?c7 :eSuplementoDe ?c8.
    ?c8 :eSuplementoDe ?c7.

    ?c9 :eSuplementoPara ?c10.
    ?c10 :eSuplementoDe ?c9.

    FILTER (
        ?c1 != ?c2
        && ?c3 != ?c4
        && ?c5 != ?c6
        && ?c7 != ?c8
        && ?c9 != ?c10
    )

}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv13}{\textbf{(inv13)}} Na relação temRelProc um PN não se relaciona com ele
  próprio.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c1 rdf:type :Classe_N3 .
    ?c2 rdf:type :Classe_N4.

    FILTER (
      EXISTS { ?c1 :eAntecessorDe ?c1 . }
      ||
      EXISTS { ?c1 :eComplementarDe ?c1 . }
      ||
      EXISTS { ?c1 :eCruzadoCom ?c1 . }
      ||
      EXISTS { ?c1 :eSinteseDe ?c1 . }
      ||
      EXISTS { ?c1 :eSintetizadoPor ?c1 . }
      ||
      EXISTS { ?c2 :eSinteseDe ?c2 . }
      ||
      EXISTS { ?c2 :eSintetizadoPor ?c2 . }
      ||
      EXISTS { ?c1 :eSucessorDe ?c1 . }
      ||
      EXISTS { ?c1 :eSuplementoDe ?c1 . }
      ||
      EXISTS { ?c1 :eSuplementoPara ?c1 . }
    )

}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv15}{\textbf{(inv15)}} Um PN só pode ter uma relação com outro PN
  (\textbf{Uma relação como assim? R: Um PN não pode ter relações
  distintas com o mesmo processo \textbar{} Que relações? As do tipo
  Classe\_N4 -\textgreater{} Classe\_N3})
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
  ?c1 rdf:type :Classe_N3 .
  ?c2 rdf:type :Classe_N3 .
  ?c1 :eAntecessorDe ?c2 .

  FILTER (
    ?c1 != ?c2
    &&
    (
    EXISTS { ?c1 :eComplementarDe ?c2 . }
    ||
    EXISTS { ?c1 :eCruzadoCom ?c2 . }
    ||
    EXISTS { ?c1 :eSinteseDe ?c2 . }
    ||
    EXISTS { ?c1 :eSintetizadoPor ?c2 . }
    ||
    EXISTS { ?c1 :eSucessorDe ?c2 . }
    ||
    EXISTS { ?c1 :eSuplementoDe ?c2 . }
    ||
    EXISTS { ?c1 :eSuplementoPara ?c2 . }
    )
  )

}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv16}{\textbf{(inv16)}} Se um PN se desdobra em 4ºs niveis os Termos de
  Indice passam para os filhos.
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c rdf:type :Classe_N3 .
    ?c :temFilho ?cf .


    FILTER (
        EXISTS { ?c :temTI ?ti .}
    )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv17}{\textbf{(inv17)}} Os termos de indice de um PN não existem em mais
  nenhuma classe 3
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where { 
    ?c1 rdf:type :Classe_N3 .
    ?c2 rdf:type :Classe_N3 .

    ?c1 :temTI ?ti .

    FILTER (
      ?c1 != ?c2
      && EXISTS { ?c2 :temTI ?ti . }
    )
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv20}{\textbf{(inv20)}} Dois PNs não podem ter a mesma instancia de DF.
\item
  \hypertarget{inv21}{\textbf{(inv21)}} Dois PNs não podem ter a mesma instancia de PCA.
\end{itemize}

\hypertarget{invariantes-sobre-a-relacaoo-suplementar-implicacoes-no-pca}{%
\subsubsection{Invariantes sobre a relação Suplementar: implicações no
PCA}\label{invariantes-sobre-a-relauxe7uxe3o-suplementar-implicauxe7uxf5es-no-pca}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv29}{\textbf{(inv29)}} Quando o PN (sem filhos) em causa
  \texttt{eSuplementoPara} outro, deve ser acrescentado um critério de
  utilidade administrativa na justificação do respetivo PCA;
  (\textbf{\texttt{eSuplementoDe} ou \texttt{eSuplementoPara} ?
  SuplementoPara \textbar{} Que PCA, o do PN em causa ou o outro? Em
  causa \textbar{} Não existe nenhuma relação do tipo
  \texttt{Justificacao\ -\textgreater{}\ CriterioJustificacao} R:
  temCriterio })

  \begin{itemize}
  \tightlist
  \item
    Nesse critério, critério de utilidade administrativa, devem aparecer
    todos os processos com os quais existe uma relação
    \texttt{eSuplementoPara}; (\textbf{Que todos os processos?? Todas as
    que o PN em CAUSA está relacionado por a relação
    \texttt{eSuplementoPara}})
  \end{itemize}
\item
  \hypertarget{inv33}{\textbf{(inv33)}} Quando o PN (com filhos) em causa
  \texttt{eSuplementoPara} outro, deve ser acrescentado um critério de
  utilidade administrativa na justificação PCA dos filhos em que os
  processos relacionados com o critério podem ser distintos.
\end{itemize}

\hypertarget{invariantes-sobre-a-relacao-sintese-implicacoes-no-df}{%
\subsubsection{Invariantes sobre a relação Síntese: implicações no
DF}\label{invariantes-sobre-a-relauxe7uxe3o-suxedntese-implicauxe7uxf5es-no-df}}

\begin{itemize}
\tightlist
\item
  Quando o PN em causa é síntese de outro, o DF deve ter o valor de
  ``Conservação'';
\item
  Quando o PN em causa é síntetizado por outro, o DF deve ter o valor de
  ``Eliminação'';
\item
  \hypertarget{inv34}{\textbf{(inv34)}} Todos os processos relacionados (sem filhos) por uma
  relação de síntese deverão estar relacionados com o critério de
  densidade informacional da respetiva justificação.
  (\texttt{critTemProcRel} \textbf{O criterio é que se relaciona com os
  processos})
\item
  \hypertarget{inv35}{\textbf{(inv35)}} Todos os processos relacionados (com filhos) por uma
  relação de síntese, os filhos deverão estar relacionados com o
  critério de densidade informacional da respetiva justificação.
  (\texttt{critTemProcRel} \textbf{O criterio é que se relaciona com os
  processos})
\end{itemize}

\hypertarget{invariantes-sobre-a-relacao-complementar-implicacoes-no-df}{%
\subsubsection{Invariantes sobre a relação Complementar: implicações no
DF}\label{invariantes-sobre-a-relauxe7uxe3o-complementar-implicauxe7uxf5es-no-df}}

\begin{itemize}
\tightlist
\item
  Uma relação de complementaridade implica a conservação dos PNs que
  mantêm essa relação; (\textbf{implica que o DF seja de conservação?
  Nos dois processos? Sim e sim})
\item
  \hypertarget{inv36}{\textbf{(inv36)}} Todos os processos relacionados (sem filhos) pela
  relação \texttt{eComplementarDe}, devem estar relacionados com o
  critério de complementaridade informacional da respetiva justificação.
\item
  \hypertarget{inv37}{\textbf{(inv37)}}Todos os processos relacionados (com filhos) pela
  relação \texttt{eComplementarDe}, os filhos devem estar relacionados
  com o critério de complementaridade informacional da respetiva
  justificação.
\end{itemize}

\hypertarget{invariantes-sobre-o-df}{%
\subsubsection{Invariantes sobre o DF}\label{invariantes-sobre-o-df}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv30}{\textbf{(inv30)}} Um DF, na sua justificação, deverá conter apenas
  critérios de densidade informacional, complementaridade informacional
  e legal
\item
  \hypertarget{inv18}{\textbf{(inv18)}} 2 DFs nao podem ter a mesma instancia de
  Justificacao;
\item
  \hypertarget{inv27}{\textbf{(inv27)}} Um DF, na sua justificação, apenas deve ter uma
  instancia de JustificacaoDF;
\end{itemize}

\hypertarget{invariantes-sobre-o-pca}{%
\subsubsection{Invariantes sobre o PCA}\label{invariantes-sobre-o-pca}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv31}{\textbf{(inv31)}} Um PCA, na sua justificação, deverá conter apenas
  critérios gestionários, utilidade administrativa e legal
\item
  \hypertarget{inv19}{\textbf{(inv19)}} 2 PCAs nao podem ter a mesma instancia de
  Justificacao;
\item
  \hypertarget{inv28}{\textbf{(inv28)}} Um PCA, na sua justificação, apenas deve ter uma
  instancia de JustificacaoPCA;
\end{itemize}

\hypertarget{invariantes-sobre-os-termos-de-indice}{%
\subsubsection{Invariantes sobre os Termos de
Índice}\label{invariantes-sobre-os-termos-de-uxedndice}}

\begin{itemize}
\tightlist
\item
  Os termos de índice são únicos no universo do sistema
\end{itemize}

\hypertarget{invariantes-das-relacoes-temrelproc}{%
\subsubsection{\texorpdfstring{Invariantes das relações
\texttt{temRelProc}}{Invariantes das relações temRelProc}}\label{invariantes-das-relauxe7uxf5es-temrelproc}}

Só se aplica ao 3º nivel.

\begin{itemize}
\tightlist
\item
  \hypertarget{inv32}{\textbf{(inv32)}} Se um PN é (por ordem de prioridade):

  \begin{itemize}
  \tightlist
  \item
    eComplementarDe -\textgreater{} DF é de conservaçao
  \item
    eSinteseDe -\textgreater{} DF é de conservação
  \item
    eSintetizadoPor -\textgreater{} DF é de eliminação
  \item
    nenhuma das acima -\textgreater{} DF é NE (Não especificado)
  \end{itemize}
\end{itemize}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :eComplementarDe ?o .
    ?c :temDF ?df.
    ?df :dfValor ?dfv.
    
    minus {
            ?c :temFilho ?f .
        }

    FILTER (?dfv != "C")
}
\end{lstlisting}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :eSinteseDe ?ca .
    ?c :temDF ?df.
    ?df :dfValor ?dfv.
    
    minus {
            ?c :temFilho ?cf .
        ?c :eComplementarDe ?cb .
    }

    FILTER (?dfv != "C")
}
\end{lstlisting}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :eSintetizadoPor ?ca .
    ?c :temDF ?df.
    ?df :dfValor ?dfv.

    minus {
            ?c :temFilho ?f .
        ?c :eComplementarDe ?cb .
        ?c :eSinteseDe ?cc .
    }

    FILTER (?dfv != "E")
}
\end{lstlisting}

\begin{lstlisting}[language=sparql, frame=single, basicstyle=\scriptsize]
PREFIX : <http://jcr.di.uminho.pt/m51-clav#>
PREFIX clav: <http://jcr.di.uminho.pt/m51-clav#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select * where {
    ?c rdf:type :Classe_N3 .
    ?c :temDF ?df.
    ?df :dfValor ?dfv.
    minus {
            ?c :temFilho ?cf .
        ?c :eComplementarDe ?ca .
        ?c :eSintetizadoPor ?cb .
        ?c :eSinteseDe ?cc .
    }
    
    FILTER (?dfv != "NE")
}
\end{lstlisting}

\hypertarget{invariantes-sobre-as-justificacoes}{%
\subsubsection{Invariantes sobre as
Justificações}\label{invariantes-sobre-as-justificauxe7uxf5es}}

\begin{itemize}
\tightlist
\item
  \hypertarget{inv23}{\textbf{(inv23)}} 2 Justificações nao podem ter a mesma instancia de
  CriterioJustificacao
\item
  \hypertarget{inv22}{\textbf{(inv22)}} Cada Justificacao tem no maximo 3
  CriterioJustificacao diferentes
\item
  \hypertarget{inv38}{\textbf{(inv38)}} Cada Justificacao tem no maximo 1 Criterio de cada
  tipo
\end{itemize}


\section{Modelo formal Alloy}

\begin{lstlisting}[language=alloy, frame=single]
open util/boolean
open RelCalc

/* Atributo Composto */
abstract sig CriterioJustificacao {
	critTemLegAssoc: set Legislacao,
	critTemProcRel: set Classe_N3
}
  sig CriterioJustificacaoComplementaridadeInfo extends CriterioJustificacao {}
  sig CriterioJustificacaoDensidadeInfo extends CriterioJustificacao {}
  sig CriterioJustificacaoGestionario extends CriterioJustificacao {}
  sig CriterioJustificacaoLegal extends CriterioJustificacao {}
  sig CriterioJustificacaoUtilidadeAdministrativa extends CriterioJustificacao {}

abstract sig DestinoFinal {
	temJustificacao: one Justificacao
}
sig Eliminacao, Conservacao, NE extends DestinoFinal {} /* dfValor :: DF -> String */

sig ExemploNotaAplicacao {}

/* Justificacao */
abstract sig Justificacao {
	temCriterio: some CriterioJustificacao
}
  sig JustificacaoDF extends Justificacao {}
  sig JustificacaoPCA extends Justificacao {}
/* ----- */

sig NotaAplicacao {
	naPertenceClasse: one Classe
}

sig NotaExclusao {
	nePertenceClasse: one Classe,
	usarClasse: set Classe
}

sig PCA {
	temJustificacao: one Justificacao,
	valor: one Int
}
/* ----- */

/* Classe */
abstract sig Classe {
	pertenceLC: lone ListaConsolidada,
	temNotaAplicacao: set NotaAplicacao,
	temNotaExclusao: set NotaExclusao,
	pertenceTS: lone TabelaSelecao,
	temExemploNA: set ExemploNotaAplicacao
}

sig Classe_N1 extends Classe {
	temFilho: set Classe_N2,
}
sig Classe_N2 extends Classe {
	temPai: one Classe_N1,
	temFilho: set Classe_N3,
}

sig Classe_N3 extends Classe {
	temPai: one Classe_N2,
	temDono: some EntidadeResponsavel, 
	temFilho: set Classe_N4,
	temTI: set TermoIndice,
	/* temRelProc */
    eAntecessorDe: lone Classe_N3,
    eComplementarDe: set Classe_N3, 
    eCruzadoCom: set Classe_N3,
    eSinteseDe: set Classe_N3,
    eSintetizadoPor: set Classe_N3,
    eSucessorDe: lone Classe_N3,
    eSuplementoDe: set Classe_N3,
    eSuplementoPara: set Classe_N3,
	/* ----- */
    /* temParticipante */
    temParticipanteComunicador: set EntidadeResponsavel,
    temParticipanteIniciador: set EntidadeResponsavel,
    temParticipanteApreciador: set EntidadeResponsavel,
    temParticipanteDecisor: set EntidadeResponsavel,
    temParticipanteAssessor: set EntidadeResponsavel,
    temParticipanteExecutor: set EntidadeResponsavel,
	/* ----- */
    temLegislacao: set Legislacao,
    temDF: lone DestinoFinal,
    temPCA: lone PCA,

	/* Relacoes de atributo */
	processoTransversal: one Bool
	/* ----- */
}

sig Classe_N4 extends Classe {
	temPai: one Classe_N3,
	temTI: set TermoIndice, // Partilha entre irmaos -- VER CAMPOS
	/* temRelProc */
	eSinteseDe: set Classe_N4,
    eSintetizadoPor: set Classe_N4,
	/* ----- */
	temDF: one DestinoFinal,
	temPCA: one PCA
}

/* Factos Classe_N4 */
fact classe_n4 {
	no Classe_N4.temNotaAplicacao
	no Classe_N4.temNotaExclusao
	no Classe_N4.temExemploNA
}
/* ----- */

abstract sig EntidadeResponsavel {
	eDonoProcesso: set Classe_N3,
 	/* participaEm */
    participaEmComunicando: set Classe_N3,
    participaEmIniciando: set Classe_N3,
    participaEmApreciando: set Classe_N3,
    participaEmDecidindo: set Classe_N3,
    participaEmAssessorando: set Classe_N3,
    participaEmExecutando: set Classe_N3,
	/* ----- */
}

sig Entidade extends EntidadeResponsavel {
	pertenceTipologiaEnt: set TipologiaEntidade
}

sig TipologiaEntidade extends EntidadeResponsavel {
	contemEntidade: some Entidade
}

sig Legislacao {
	temEntidadeResponsavel: set EntidadeResponsavel
}

/* ReferencialClassificativo */
abstract sig ReferencialClassificativo {
	temClasse: set Classe
}
sig ListaConsolidada extends ReferencialClassificativo {}
sig TabelaSelecao extends ReferencialClassificativo {}
/* ----- */

sig TermoIndice {
	estaAssocClasse: one Classe_N3 + Classe_N4
}

/* FACTOS */
fact {
	/* Relacoes inversas */
	-- pertenceLC
	pertenceLC in ~temClasse

	-- temFilho
	~(Classe_N1<:temFilho) = (Classe_N2<:temPai)
	~(Classe_N2<:temFilho) = (Classe_N3<:temPai)
	~(Classe_N3<:temFilho) = (Classe_N4<:temPai)

	-- temNotaAplicacao
	~temNotaAplicacao in naPertenceClasse

	-- temNotaExclusao
	~temNotaExclusao in nePertenceClasse

	-- temDono
	~eDonoProcesso in temDono

	-- temTI
	~(Classe_N3<:temTI) in estaAssocClasse
	~(Classe_N4<:temTI) in estaAssocClasse
	
	-- temRelProc
	  -- eAntecessorDe/eSucessorDe
	  ~eAntecessorDe = eSucessorDe
      -- eSinteseDe/eSintetizadoPor
	  ~(Classe_N3<:eSinteseDe) = Classe_N3<:eSintetizadoPor
	  ~(Classe_N4<:eSinteseDe) = Classe_N4<:eSintetizadoPor
      -- eSuplementoDe/eSuplementoPara
	  ~eSuplementoDe = eSuplementoPara

	-- temParticipante
      -- temParticipanteComunicador
	  ~participaEmComunicando in temParticipanteComunicador
      -- temParticipanteIniciador
      ~participaEmIniciando in temParticipanteIniciador
      -- temParticipanteApreciador
      ~participaEmApreciando in temParticipanteApreciador
      -- temParticipanteDecisor
      ~participaEmDecidindo in temParticipanteDecisor
      -- temParticipanteAssessor
      ~participaEmAssessorando in temParticipanteAssessor
      -- temParticipanteExecutor
      ~participaEmExecutando in temParticipanteExecutor

	-- temLegislacao VER NO FUTURO

	-- contemEntidade
	~contemEntidade = pertenceTipologiaEnt
	/* ----- */
}

/* INVARIANTES */

/* Se uma Classe_N1 pertence a uma LC/TS, consequentemente os seus filhos,netos,etc..
   tambem tem de pertencer
*/
pred inv1 {
	all c:Classe_N1,lc:ListaConsolidada | lc = c.pertenceLC =>
		(all cf:c.temFilho | lc = cf.pertenceLC) and
		(all cf:c.temFilho.temFilho | lc = cf.pertenceLC) and
	    (all cf:c.temFilho.temFilho.temFilho | lc = cf.pertenceLC)

	all c:Classe_N1,ts:TabelaSelecao | ts = c.pertenceTS =>
		(all cf:c.temFilho | ts = cf.pertenceTS) and
		(all cf:c.temFilho.temFilho | ts = cf.pertenceTS) and
	    (all cf:c.temFilho.temFilho.temFilho | ts = cf.pertenceTS)
}

/* Se uma Classe_N1 nao pertence a uma LC/TS, consequentemente os seus filhos,netos,etc.. tambem nao pertencem */
pred inv2 {
	all c:Classe_N1 | no c.pertenceLC =>
		(all cf:c.temFilho | no cf.pertenceLC) and
		(all cf:c.temFilho.temFilho | no cf.pertenceLC) and
	    (all cf:c.temFilho.temFilho.temFilho | no cf.pertenceLC)

	all c:Classe_N1 | no c.pertenceTS =>
		(all cf:c.temFilho | no cf.pertenceTS) and
		(all cf:c.temFilho.temFilho | no cf.pertenceTS) and
	    (all cf:c.temFilho.temFilho.temFilho | no cf.pertenceTS)
}

/* As relacoes temDF e temPCA, nao existem numa classe 3 se esta tiver filhos. */
pred inv3 {
	all c:Classe_N3 | some c.temFilho => no c.temDF and no c.temPCA
}

/* As relacoes temDF e temPCA, existem numa classe 3 se esta nao tiver filhos. */
pred inv4 {
	all c:Classe_N3 | no c.temFilho => one c.temDF and one c.temPCA
}

/* Nas classes 3 com desdobramento */

/* Os 4os niveis herdam as legislacoes existentes no 3o nivel (subconjunto), quer para o PCA quer para o DF. */
pred inv5 {
	all c:Classe_N3 | some c.temFilho => {
	(c.temFilho.temPCA.temJustificacao.temCriterio.critTemLegAssoc 
	 + c.temFilho.temDF.temJustificacao.temCriterio.critTemLegAssoc) in c.temLegislacao
	}
}

/* Apenas se desdobram devido a um PCA distinto ou DF distinto */
pred inv6 {
	all c:Classe_N3 | #c.temFilho > 1 => (#c.temFilho.temDF > 1) or 
					 (#c.temFilho.temPCA > 1 and (all p1,p2:c.temFilho.temPCA | p1.valor != p2.valor))
}

/* Caso o motivo de desdobramento seja PCA distinto:
     - Caso o DF seja distinto tem que haver uma relacao de sintese entre as classes 4 filhas
*/
pred inv7 {
	all c:Classe_N3 | #c.temFilho > 1
                  and (#c.temFilho.temPCA > 1)
                  and (#c.temFilho.temDF > 1)
                    => (all disj c1,c2:c.temFilho |
                      c1->c2 in eSinteseDe <=>
                      (c1.temDF in Conservacao) and (c2.temDF in Eliminacao))
}


/* Caso o motivo de desdobramento seja DF distinto:
     - Tem que haver uma relacao de sintese entre as classes 4 filhas
	 - O PCA e igual
*/
pred inv8 {
	all c:Classe_N3 | #c.temFilho > 1 and 
					  (c.temFilho.temDF not in Eliminacao) and
					  (c.temFilho.temDF not in Conservacao) =>
					  one c.temFilho.temPCA.valor and
					  (all disj c1,c2:c.temFilho {
 					  	(c1.temDF in Conservacao) and (c2.temDF in Eliminacao) =>
					  	c1->c2 in eSinteseDe
					  })
}

/* Os termos de indice vao para os 4os niveis */
pred inv9 {
	all c:Classe_N3,t:c.temTI | some c.temFilho => t in c.temFilho.temTI
}

/* Se um PN (Classe 3) for complementar de outro que se desdobra ao 4o nivel, e necessario, 
   com base no criterio de complementaridade informacional, a relacao manter-se ao 3o nivel. 
   Pelo menos um dos 4os niveis deve ser de conservacao. */
pred inv10 {
	all disj c1,c2:Classe_N3 | c1 in c2.eComplementarDe and some c2.temFilho => some c3:c2.temFilho | c3.temDF in Conservacao
}

/* Um processo so tem participantes se for transveral */
pred inv11 {
	all c:Classe_N3 | False = c.processoTransversal => no 
		(c.temParticipanteComunicador 
		+ c.temParticipanteIniciador
		+ c.temParticipanteApreciador
		+ c.temParticipanteDecisor
    	+ c.temParticipanteAssessor
    	+ c.temParticipanteExecutor)
}

/* As relacoes eComplementarDe e eCruzadoCom sao simetricas. */
pred inv12 {
	Symmetric[eComplementarDe]
	Symmetric[eCruzadoCom]
}

/* Na relacao temRelProc um PN nao se relaciona com ele proprio */
pred inv13 {
    all c:Classe_N3 | c->c not in eAntecessorDe
    all c:Classe_N3 | c->c not in eComplementarDe
    all c:Classe_N3 | c->c not in eCruzadoCom
    all c:Classe_N3 | c->c not in eSinteseDe
    all c:Classe_N3 | c->c not in eSintetizadoPor
    all c:Classe_N4 | c->c not in eSinteseDe
    all c:Classe_N4 | c->c not in eSintetizadoPor
    all c:Classe_N3 | c->c not in eSucessorDe
    all c:Classe_N3 | c->c not in eSuplementoDe
    all c:Classe_N3 | c->c not in eSuplementoPara
}

/* As relacoes eSinteseDe, eSucessorDe e eSuplementoDe sao antimetricas. */
pred inv14 {
	Antisymmetric[Classe_N3<:eSinteseDe, Classe_N3]
	Antisymmetric[Classe_N3<:eSintetizadoPor, Classe_N3]
	Antisymmetric[Classe_N4<:eSinteseDe, Classe_N4]
	Antisymmetric[Classe_N4<:eSintetizadoPor, Classe_N4]

	Antisymmetric[eSucessorDe, Classe_N3]
	Antisymmetric[eAntecessorDe, Classe_N3]

	Antisymmetric[eSuplementoDe, Classe_N3]
	Antisymmetric[eSuplementoPara, Classe_N3]
}

/* Um PN so pode ter uma relacao com outro PN */
pred inv15 {
	all c1,c2:Classe_N3 | c1->c2 in eAntecessorDe => c1->c2 not in
		eComplementarDe + eCruzadoCom + eSinteseDe + eSintetizadoPor + eSucessorDe + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eComplementarDe => c1->c2 not in
		eAntecessorDe + eCruzadoCom + eSinteseDe + eSintetizadoPor + eSucessorDe + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eCruzadoCom => c1->c2 not in
		eAntecessorDe + eComplementarDe + eSinteseDe + eSintetizadoPor + eSucessorDe + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eSinteseDe => c1->c2 not in
	 	eAntecessorDe + eComplementarDe + eCruzadoCom + eSintetizadoPor + eSucessorDe + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eSintetizadoPor => c1->c2 not in
		eAntecessorDe + eComplementarDe + eCruzadoCom + eSinteseDe + eSucessorDe + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eSucessorDe => c1->c2 not in
		eAntecessorDe + eComplementarDe + eCruzadoCom + eSinteseDe + eSintetizadoPor + eSuplementoDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eSuplementoDe => c1->c2 not in
		eAntecessorDe + eComplementarDe + eCruzadoCom + eSinteseDe + eSintetizadoPor + eSucessorDe + eSuplementoPara
	or
	all c1,c2:Classe_N3 | c1->c2 in eSuplementoPara => c1->c2 not in
		eAntecessorDe + eComplementarDe + eCruzadoCom + eSinteseDe + eSintetizadoPor + eSucessorDe + eSuplementoDe
}

/* Se um PN se desdobra em 4os niveis os Termos de Indice passam para os filhos */
pred inv16 {
	all c:Classe_N3 | some c.temFilho => no c.temTI
}

/* Os Termos de Indice de um PN nao podem existir em mais nenhuma classe 3 */
pred inv17 {
	all disj c1,c2:Classe_N3,ti:TermoIndice | ti in c1.temTI => ti not in c2.temTI
}

/* 2 DFs nao podem ter a mesma instancia de Justificacao */
pred inv18 {
	all disj d1,d2:DestinoFinal | d1.temJustificacao != d2.temJustificacao
}

/* 2 DFs nao podem ter a mesma instancia de Justificacao */
pred inv19 {
	all disj pca1,pca2:PCA | pca1.temJustificacao != pca2.temJustificacao
}

/* 2 PNs nao podem ter a mesma instancia de DF */
pred inv20 {
	all disj c1,c2:Classe_N3 {
		c1.temDF != c2.temDF
	}
	all disj c1,c2:Classe_N4 {
		c1.temDF != c2.temDF
	}
	all disj c1:Classe_N3,c2:Classe_N4 {
		c1.temDF != c2.temDF
	}
}

/* 2 PNs nao podem ter a mesma instancia de PCA */
pred inv21 {
	all disj c1,c2:Classe_N3 {
		c1.temPCA != c2.temPCA
	}
	all disj c1,c2:Classe_N4 {
		c1.temPCA != c2.temPCA
	}
	all disj c1:Classe_N3,c2:Classe_N4 {
		c1.temPCA != c2.temPCA
	}
}

/* Cada Justificacao tem no maximo 3 CriterioJustificacao diferentes */ 
pred inv22 {
	all j:Justificacao | #j.temCriterio <= 3
}

/* 2 Justificacoes nao podem ter a mesma instancia de CriterioJustificacao */
pred inv23 {
	all disj j1,j2:Justificacao | all c:CriterioJustificacao | c in j1.temCriterio => c not in j2.temCriterio
}

/* 2 Classes nao podem ter a mesma instancia NotaAplicacao
   2 Classes nao podem ter a mesma instancia NotaExclusao
   2 Classes nao podem ter a mesma instancia ExemploNotaAplicacao
*/
pred inv24 {
	all disj c1,c2:Classe | all n:NotaAplicacao | n in c1.temNotaAplicacao => n not in c2.temNotaAplicacao
	all disj c1,c2:Classe | all n:NotaExclusao | n in c1.temNotaExclusao => n not in c2.temNotaExclusao
	all disj c1,c2:Classe | all n:ExemploNotaAplicacao | n in c1.temExemploNA => n not in c2.temExemploNA
}

/* 2 Classes N3 nao podem ter os mesmos filhos */
pred inv25 {
	all disj c1,c2:Classe_N3 | all c3:Classe_N4 | c3 in c1.temFilho => c3 not in c2.temFilho
}

/* 2 Classe_N3 nao podem ter o mesmo TI */
pred inv26 {
	all disj c1,c2:Classe_N3 | all t:TermoIndice | t in c1.temTI => t not in c2.temTI
}

/* UM DF, na sua justificacao, apenas deve ter uma instancia de JustificacaoDF */
pred inv27 {
	all df:DestinoFinal | df.temJustificacao in JustificacaoDF
}

/* UM PCA, na sua justificacao, apenas deve ter uma instancia de JustificacaoPCA */
pred inv28 {
	all pca:PCA | pca.temJustificacao in JustificacaoPCA
}

/* Quando o PN (sem filhos) em causa `eSuplementoPara` outro, 
   deve ser acrescentado um criterio de utilidade administrativa na justificacao do respetivo PCA
*/
pred inv29 {
	all c:Classe_N3 | no c.temFilho and some c.eSuplementoPara => one crit:CriterioJustificacaoUtilidadeAdministrativa {
		crit in c.temPCA.temJustificacao.temCriterio and crit.critTemProcRel = c.eSuplementoPara
	}
}

/* Um DF, na sua justificacao, devera conter apenas criterios de densidade informacional, complementaridade informacional e legal */
pred inv30 {
	all df:DestinoFinal | all crit:df.temJustificacao.temCriterio {
		(crit in CriterioJustificacaoDensidadeInfo) or
		(crit in CriterioJustificacaoComplementaridadeInfo) or
		(crit in CriterioJustificacaoLegal)
	}
}

/* Um PCA, na sua justificacao, devera conter apenas criterios gestionarios, utilidade administrativa e legal */
pred inv31 {
	all pca:PCA | all crit:pca.temJustificacao.temCriterio {
		(crit in CriterioJustificacaoGestionario) or
		(crit in CriterioJustificacaoUtilidadeAdministrativa) or
		(crit in CriterioJustificacaoLegal)
	}
}

/* 
Se um PN e (por ordem de prioridade):
    - eComplementarDe   -> DF e de conservacao
    - eSinteseDe        -> DF e de conservacao
    - eSintetizadoPor   -> DF e de eliminacao
    - nenhuma das acima -> DF e NE (Nao especificado)
*/
pred inv32 {
	all c:Classe_N3 | no c.temFilho => {
		some c.eComplementarDe => c.temDF in Conservacao
	}
	all c:Classe_N3 | no c.temFilho => {
		!(some c.eComplementarDe) and (some c.eSinteseDe) => c.temDF in Conservacao
	}
	all c:Classe_N3 | no c.temFilho => {
		!(some c.eComplementarDe) and !(some c.eSinteseDe) and (some c.eSintetizadoPor) => c.temDF in Eliminacao
	}
	all c:Classe_N3 | no c.temFilho => {
		!(some c.eComplementarDe) and !(some c.eSinteseDe) and !(some c.eSintetizadoPor) => c.temDF in NE
	}
}

/* Quando o PN (com filhos) em causa `eSuplementoPara` outro, 
   deve ser acrescentado um criterio de utilidade administrativa na 
   justificacao PCA dos filhos em que os processos relacionados com
   o criterio podem ser distintos. 
*/
pred inv33 {
	all c:Classe_N3 | some c.temFilho and some c.eSuplementoPara => 
		all c2:c.temFilho {
			one crit:CriterioJustificacaoUtilidadeAdministrativa {
				crit in c2.temPCA.temJustificacao.temCriterio
				crit.critTemProcRel in c.eSuplementoPara
			}
		}
}

/* Todos os processos relacionados (sem filhos) por uma relacao de sintese deverao
   estar relacionados com o criterio de densidade informacional da
   respetiva justificacao.
*/
pred inv34 {
	all c:Classe_N3 | no c.temFilho and (some c.eSinteseDe) => one crit:CriterioJustificacaoDensidadeInfo {
		crit in c.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eSinteseDe
	}
	all c:Classe_N3 | no c.temFilho and (some c.eSintetizadoPor) => one crit:CriterioJustificacaoDensidadeInfo {
		crit in c.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eSintetizadoPor
	}
}

/* Todos os processos relacionados (com filhos) por uma relacao de sintese deverao
   estar relacionados com o criterio de densidade informacional da
   respetiva justificacao.
*/
pred inv35 {
	all c:Classe_N3 | some c.temFilho and (some c.eSinteseDe) => 
		all c2:c.temFilho {
			one crit:CriterioJustificacaoDensidadeInfo {
				crit in c2.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eSinteseDe
			}
		}
	all c:Classe_N3 | some c.temFilho and (some c.eSintetizadoPor) => 
		all c2:c.temFilho {
			one crit:CriterioJustificacaoDensidadeInfo {
				crit in c2.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eSintetizadoPor
			}
		}
}

/*
	Todos os processos relacionados (sem filhos) pela relacao eComplementarDe,
	devem estar relacionados com o criterio de complementaridade
	informacional da respetiva justificacao.
*/
pred inv36 {
	all c:Classe_N3 | no c.temFilho and (some c.eComplementarDe) => one crit: CriterioJustificacaoComplementaridadeInfo {
		crit in c.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eComplementarDe
	}
	all c:Classe_N3 | no c.temFilho and (some eComplementarDe.c) => one crit: CriterioJustificacaoComplementaridadeInfo {
		crit in c.temDF.temJustificacao.temCriterio and crit.critTemProcRel = eComplementarDe.c
	}
}

/*
	Todos os processos relacionados (com filhos) pela relacao eComplementarDe,
	os filhos devem estar relacionados com o criterio de complementaridade
	informacional da respetiva justificacao.
*/
pred inv37 {
	all c:Classe_N3 | some c.temFilho and (some c.eComplementarDe) => 
		all c2:c.temFilho {
			one crit: CriterioJustificacaoComplementaridadeInfo {
				crit in c2.temDF.temJustificacao.temCriterio and crit.critTemProcRel = c.eComplementarDe
			}
		}
	all c:Classe_N3 | some c.temFilho and (some eComplementarDe.c) => 
		all c2:c.temFilho {
			one crit: CriterioJustificacaoComplementaridadeInfo {
				crit in c2.temDF.temJustificacao.temCriterio and crit.critTemProcRel = eComplementarDe.c
			}
		}
}

/*
	Cada justificacao tem no maximo 1 Criterio de cada tipo.
*/
pred inv38 {
	all j:Justificacao {
		lone crit1:CriterioJustificacaoComplementaridadeInfo | crit1 in j.temCriterio
  		lone crit2:CriterioJustificacaoDensidadeInfo | crit2 in j.temCriterio
  		lone crit3:CriterioJustificacaoGestionario | crit3 in j.temCriterio
  		lone crit4:CriterioJustificacaoLegal | crit4 in j.temCriterio
  		lone crit5:CriterioJustificacaoUtilidadeAdministrativa | crit5 in j.temCriterio
	}
}
\end{lstlisting}{}

\end{subappendices}


\end{document}
